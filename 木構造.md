---
tags:
  - base
---

# 木構造(階層構造)

パーツリストを作成する際に木構造関して調査しました。

## モデル

https://qiita.com/fktnkit/items/57033c10b41b5747dbea

- 隣接ツリーモデル
  わかりやすいのだけれど、SQL の世界ではアンチパターンとされている
  【理由】

  - ツリー全体、もしくはある要素のサブツリーが取得しづらい。
  - 非葉ノードを削除した際に整合性を取りづらい。

- 経路列挙モデル
- 入れ子集合モデル

## パーツリストに関しては

隣接ツリーモデルを採用することにしました。

### 理由

1. ツリー全体は python ライブラリで見ることができる
1. 編集はツリー全体に変換してから実施するので、不整合は起こらないはず。また SQL と違い、今回はバージョン管理を実施するので、間違いがあったら分かる
1. 複数人が同時に改定を実施して、コンフリクトが起こらないようにするには、これが一番よい

## どうやって並べ替えるか???

行がバラバラになってしまった場合、どうやって再構築するか問題。。。index の順番さえ決められれば、並べ替えは pandsa で可能

1. フルパス化して並べ替える → よさげなライブラリなし。、、
1. ライブラリを使う(python なら anytree) → できるけど、時間が掛かりそう。。。
1. 再帰処理可能な SQL に入れて、パターンを適用 → DB は処理が早いので、やってくれそう、sqlite かな?
1. フォルダとファイルを作って、実体化してパスを取得してしまえ!!!なんて強引な。。。 → みてわかる!人間には優しいけれど、時間がかかる プロトタイプならありかな?
1. anytree のソースを見て、ソート関数を作成する → 最終的にはコレでしょうね。関数化して pandas で一気に適用が吉!!! 全データを渡して、インデックスの順番を返す関数。これがあれば、pandas は数字のソートのみで OK

### pandas 行をリストで指定して並べかえ

```python
import pandas as pd
df = pd.DataFrame({'A': [1, 2, 3], 'B': [10, 20, 30], 'C': [100, 200, 300]},
                  index=['One', 'Two', 'Three'])
df.reindex(index=['Two', 'Three', 'One'])
df.reindex(columns=['B', 'C', 'A'])
df.reindex(index=['Two', 'Three', 'One'], columns=['B', 'C', 'A'])
```
